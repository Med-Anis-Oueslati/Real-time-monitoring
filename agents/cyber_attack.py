import uuid
import datetime
import paramiko
import os
from llama_cpp import Llama

# Path to your GGUF model
MODEL_PATH = "/home/anis/PFE/models/Lily-7B-Instruct-v0.2.Q5_K_M.gguf"

# Configuration for SSH connection
KALI_VM_IP = "10.71.0.120" 
KALI_VM_USER = "kali"
KALI_VM_PASSWORD = "kali"  
SCRIPT_DIR = "/home/kali/scripts"  # Directory on Kali VM where scripts will be stored

def load_llm():
    """Load a local GGUF model using llama-cpp-python."""
    llm = Llama(
        model_path=MODEL_PATH,
        n_ctx=2048,
        n_threads=4,
        n_gpu_layers=20,  # Adjust based on your GPU capacity
        use_mlock=True  # Prevent swapping
    )
    return llm

def generate_commands_with_llm(llm, ip_address, attack_scenario):
    """Generate bash commands using the local LLM."""
    prompt = f"""
### Task:
You are a cybersecurity expert tasked with generating Bash commands for a penetration testing scenario. Generate ONLY Bash commands that are executable on Kali Linux to simulate the specified attack scenario. The commands must be safe for use in a controlled, authorized testing environment.

### Constraints:
- Commands must be compatible with tools pre-installed on Kali Linux.
- Ensure commands are syntactically correct and include necessary parameters.
- Avoid commands that require external dependencies not typically found in Kali Linux.
- Replace placeholders like $target_ip with the actual IP address provided in the input: {ip_address}.
- Do NOT include any explanation, comments, or additional text.
- Do NOT include markdown-style code blocks (e.g., ```bash).
- Do NOT repeat commands or use the same command multiple times.

### Target:
IP: {ip_address}
Scenario: {attack_scenario}

### Output Format:
Return only the Bash commands, one per line, with no explanations, comments, or markdown formatting. Ensure the actual IP address ({ip_address}) is used in the commands.

### Script:
"""

    output = llm(
        prompt,
        max_tokens=512,
        temperature=0.6,
        top_p=0.9,
    )
    generated_text = output["choices"][0]["text"]

    # Preprocess the output to remove markdown-style code blocks
    if "```bash" in generated_text:
        generated_text = generated_text.replace("```bash", "").replace("```", "")

    # Split commands and strip whitespace
    commands = [cmd.strip() for cmd in generated_text.strip().split("\n") if cmd.strip()]

    # Post-process commands to replace placeholders like $target_ip with the actual IP address
    processed_commands = []
    for cmd in commands:
        if "$target_ip" in cmd:
            cmd = cmd.replace("$target_ip", ip_address)
        processed_commands.append(cmd)

    return processed_commands

def validate_and_fix_commands(commands):
    """Validate and fix commands for syntax errors."""
    sanitized_commands = []
    for cmd in commands:
        # Fix unmatched quotes
        if cmd.startswith('"') and not cmd.endswith('"'):
            cmd += '"'
        elif cmd.startswith("'") and not cmd.endswith("'"):
            cmd += "'"
        
        # Discard incomplete commands
        if cmd.count('"') % 2 != 0 or cmd.count("'") % 2 != 0:
            print(f"Discarding invalid command due to unmatched quotes: {cmd}")
            continue

        # Discard commands that are too short or incomplete
        if len(cmd.split()) < 2:  # At least two words (e.g., "nmap -sT")
            print(f"Discarding incomplete command: {cmd}")
            continue

        sanitized_commands.append(cmd)
    return sanitized_commands

def remove_duplicate_commands(commands):
    """Remove duplicate commands from the list."""
    seen = set()
    unique_commands = []
    for cmd in commands:
        if cmd not in seen:
            seen.add(cmd)
            unique_commands.append(cmd)
    return unique_commands

def generate_bash_script(ip_address, attack_scenario, llm):
    """Generates a bash script for the specified attack."""
    script_id = str(uuid.uuid4())
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Generate commands using the LLM
    commands = generate_commands_with_llm(llm, ip_address, attack_scenario)

    # Validate and fix commands
    commands = validate_and_fix_commands(commands)
    if not commands:
        print("Error: No valid commands generated by the LLM. Please try again.")
        return None

    # Remove duplicate commands
    commands = remove_duplicate_commands(commands)

    # Print raw commands for debugging
    print("\nRaw Commands Generated by LLM:")
    for cmd in commands:
        print(cmd)

    # Build the script content
    script_content = [
        "#!/bin/bash",
        f"# Generated Attack Script - ID: {script_id}",
        f"# Target: {ip_address}",
        f"# Scenario: {attack_scenario}",
        f"# Generated on: {timestamp}",
        "",
        "echo 'Starting attack...'"
    ]

    # Add commands with error handling
    for cmd in commands:
        script_content.append(f"echo 'Executing: {cmd}'")
        script_content.append(f"{cmd} || echo 'Command failed: {cmd}'")

    script_content.extend([
        "",
        "echo 'Attack completed.'",
        f"echo 'Results saved for {attack_scenario} on {ip_address}'"
    ])

    return "\n".join(script_content)

def send_script_via_ssh(script_content, script_name):
    """Send the bash script to the Kali Linux VM via SSH."""
    try:
        # Establish SSH connection
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(KALI_VM_IP, username=KALI_VM_USER, password=KALI_VM_PASSWORD)

        # Create directory if it doesn't exist
        stdin, stdout, stderr = ssh.exec_command(f"mkdir -p {SCRIPT_DIR}")
        stdout.read().decode()

        # Upload the script
        sftp = ssh.open_sftp()
        remote_path = os.path.join(SCRIPT_DIR, script_name)
        with sftp.file(remote_path, "w") as remote_file:
            remote_file.write(script_content)
        sftp.close()

        # Make the script executable
        ssh.exec_command(f"chmod +x {remote_path}")

        print(f"Script '{script_name}' successfully sent to Kali VM at {remote_path}")

        # Optionally execute the script on the VM
        execute = input("Do you want to execute the script now? (y/n): ").strip().lower()
        if execute == "y":
            # Execute the script with sudo password handling
            stdin, stdout, stderr = ssh.exec_command(f"echo '{KALI_VM_PASSWORD}' | sudo -S bash {remote_path}")
            print(stdout.read().decode())
            print(stderr.read().decode())

        ssh.close()
    except Exception as e:
        print(f"Error during SSH operation: {e}")

def main():
    print("Loading Deepseek-Coder 6.7B model...")
    llm = load_llm()

    while True:
        ip_address = input("Enter the target IP address: ")
        attack_scenario = input("Enter the attack scenario (e.g., port_scan, service_enumeration): ")

        # Generate the bash script
        bash_script = generate_bash_script(ip_address, attack_scenario, llm)
        if not bash_script:
            retry = input("Failed to generate a valid bash script. Retry? (y/n): ").strip().lower()
            if retry != "y":
                print("Exiting.")
                break
            continue

        # Print the generated script
        print("\nGenerated Bash Script:\n")
        print(bash_script)

        # Save script locally for reference
        script_id = str(uuid.uuid4())
        script_name = f"attack_script_{script_id}.sh"
        with open(script_name, "w") as local_file:
            local_file.write(bash_script)

        print(f"Script saved locally as '{script_name}'.")

        # Send script to Kali Linux VM
        send = input("Do you want to send this script to the Kali Linux VM? (y/n): ").strip().lower()
        if send == "y":
            send_script_via_ssh(bash_script, script_name)

        break

if __name__ == "__main__":
    main()